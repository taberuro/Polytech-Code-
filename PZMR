ПРАКТИКА 



#pragma config(Sensor, S1,     TouchS,         sensorTouch)
//!!Code automatically generated by 'ROBOTC' configuration wizard               !!

task main()
{
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;

// we need 5 step
	for (int I = 0; I<11;I++){
    // aae?aiea ia 4 eeaoee i?yii
		if (I == 1){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}

		if (I == 2){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}

		if (I == 3){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}
		if (I == 4){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}
		// iiai?io iai?aai
		if (I==5){
		while ( nMotorEncoder[motorC] < 343 ){
					motor[motorC] = 75;
				}
				motor[motorC] = 0;
				wait1Msec(1000);
				nMotorEncoder[motorC] = 0;

				while (nMotorEncoder[motorB] > -40 && nMotorEncoder[motorC] > -40 ){
					motor[motorB] = -75;
					motor[motorC] = -75;
				}
			}
		// aae?aiea ia 3 eeaoee aia??a
		if (I == 6){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}
		if (I == 7){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}
		if (I == 8){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}
		// iiai?io iaeaai
		if (I==9){
		while ( nMotorEncoder[motorB] < 343 ){
					motor[motorB] = 75;
				}
				motor[motorB] = 0;
				wait1Msec(1000);
				nMotorEncoder[motorB] = 0;

				while (nMotorEncoder[motorB] > -40 && nMotorEncoder[motorC] > -40 ){
					motor[motorB] = -75;
					motor[motorC] = -75;
				}
			}
		// aae?aiea ia eeaoeo aia??a (ai noii)
		if (I == 10){
		while (nMotorEncoder[motorB] < 1230 && nMotorEncoder[motorC] < 1230 )
			{
				motor[motorB] = 75;
				motor[motorC] = 75;
			}
			motor[motorB] = 0;
			motor[motorC] = 0;
			wait1Msec(1000);
			nMotorEncoder[motorB] = 0;
			nMotorEncoder[motorC] = 0;
		}
  }
}



LAB 1


#pragma config(Sensor, S1,     TouchS,         sensorTouch)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	int count = 0;
	for ( int i = 0; i<5; i++)
	{

		while (SensorValue(TouchS) == 0 )
		{
			motor[motorB] = 75;
			motor[motorC] = 75;

		}

		if ((SensorValue(TouchS) == 1) && (count == 0))
		{
			wait1Msec(1000);
			motor[motorB] = -75;
			motor[motorC] = -75;
			wait1Msec(870);
			motor[motorC] = 0;
			motor[motorB] = 0;
			wait1Msec(1000);
			motor[motorC] = 75;
			wait1Msec(550);
			count = 1;
			motor[motorC] = 0;
			wait1Msec(1000);

		}



		if ((SensorValue(TouchS) == 1) && (count == 1))
		{
			wait1Msec(1000);
			motor[motorB] = -75;
			motor[motorC] = -75;
			wait1Msec(870);
			motor[motorC] = 0;
			motor[motorB] = 0;
			wait1Msec(1000);
			motor[motorB] = 75;
			wait1Msec(550);
			motor[motorB] = 0;
			wait1Msec(1000);

		}
	}
}




LAB 2


#pragma config(Sensor, S3, Lgt, sensorLightActive)

//*!!Code automatically generated by 'ROBOTC' configuration wizard !!*//

void re (){

motor[motorB] = 0;

motor[motorC] = 0;

nMotorEncoder[motorB] = 0;

nMotorEncoder[motorC] = 0;

wait1Msec(1000);

}

int LightTreshold = 45;

task main()

{

nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

nMotorEncoder[motorB] = 0;

nMotorEncoder[motorC] = 0;

for (int i = 0; i<4; i++)

{

while (SensorValue[Lgt] >= LightTreshold)

{

motor[motorB] = 50;

motor[motorC] = 50;

}

re();

while ((nMotorEncoder[motorB] < 400) && (nMotorEncoder[motorC] < 400)){

motor[motorB] = 50;

motor[motorC] = 50;

}

re();

motor[motorC] = 50;

motor[motorB] = 0;

wait1Msec(798);

re();

}

}


LAB 3


*

//Синхронизация моторов

task main()

{

nSyncedMotors = synchBC;

nSyncedTurnRatio = +100;

motor[motorB]=50;

wait1Msec(4500);

nSyncedTurnRatio = -100;

nMotorEncoderTarget[motorB]=156;

motor[motorB]=50;

wait1Msec(1000);

nSyncedTurnRatio = +100;

motor[motorB]=50;

wait1Msec(3000);

nSyncedMotors = synchCB;

nSyncedTurnRatio = -100;

nMotorEncoderTarget[motorC]=156;

motor[motorC]=50;

wait1Msec(1000);

nSyncedTurnRatio = +100;

motor[motorC]=50;

wait1Msec(2000);

nSyncedTurnRatio = -100;

nMotorEncoderTarget[motorC]=156;

motor[motorC]=50;

wait1Msec(1000);

nSyncedTurnRatio = +100;

motor[motorC]=50;

wait1Msec(1500);

}

*/

/*

//Ручная настройка

void refresh(){

motor[motorB] = 0;

motor[motorC] = 0;

nMotorEncoder[motorB] = 0;

nMotorEncoder[motorC] = 0;

}

task main()

{

refresh();

nMotorEncoderTarget[motorB] = 2000;

nMotorEncoderTarget[motorC] = 2000;

motor[motorB] = 73;

motor[motorC] = 75;

wait1Msec(4000);

refresh();

nMotorEncoderTarget[motorB] = 304;

motor[motorB] = 62;

wait1Msec(1700);

refresh();

nMotorEncoderTarget[motorB] = 1260;

nMotorEncoderTarget[motorC] = 1260;

motor[motorB] = 73;

motor[motorC] = 75;

wait1Msec(3000);

refresh();

nMotorEncoderTarget[motorC] = 305;

motor[motorC] = 62;

wait1Msec(1600);

refresh();

nMotorEncoderTarget[motorB] = 616;

nMotorEncoderTarget[motorC] = 616;

motor[motorB] = 73;

motor[motorC] = 75;

wait1Msec(3000);

refresh();

nMotorEncoderTarget[motorC] = 305;

motor[motorC] = 62;

motor[motorB] = -5;

wait1Msec(1700);

refresh();

motor[motorB] = 55;

motor[motorC] = 55;

wait1Msec(1500);

}

*/

/*

//П регулятор

void refresh(){

motor[motorB] = 0;

motor[motorC] = 0;

wait1Msec(1000);

nMotorEncoder[motorB] = 0;

nMotorEncoder[motorC] = 0;

}

task main()

{

int v = 50, k = 3, e2, e3, u;

nMotorEncoder[motorB] = 0;

nMotorEncoder[motorC] = 0;

while (nMotorEncoder[motorB] < 2000){

e2 = nMotorEncoder[motorB];

e3 = nMotorEncoder[motorC];

u = k*(e3 - e2);

motor[motorB] = v + u;

motor[motorC] = v - u;

wait1Msec(2);

}

refresh();

e2 = nMotorEncoder[motorB];

e3 = nMotorEncoder[motorC];

u = k*(e3 - e2);

motor[motorB] = v + u;

motor[motorC] = 0 - u;

wait1Msec(798);

refresh();

while (nMotorEncoder[motorB] < 1260){

e2 = nMotorEncoder[motorB];

e3 = nMotorEncoder[motorC];

u = k*(e3 - e2);

motor[motorB] = v + u;

motor[motorC] = v - u;

wait1Msec(2);

}

refresh();

e2 = nMotorEncoder[motorB];

e3 = nMotorEncoder[motorC];

u = k*(e3 - e2);

motor[motorB] = 0 + u;

motor[motorC] = v - u;

wait1Msec(798);

refresh();

while (nMotorEncoder[motorB] < 615){

e2 = nMotorEncoder[motorB];

e3 = nMotorEncoder[motorC];

u = k*(e3 - e2);

motor[motorB] = v + u;

motor[motorC] = v - u;

wait1Msec(2);

}

refresh();

e2 = nMotorEncoder[motorB];

e3 = nMotorEncoder[motorC];

u = k*(e3 - e2);

motor[motorB] = 0 + u;

motor[motorC] = v - u;

wait1Msec(798);

refresh();

while (nMotorEncoder[motorB] < 615){

e2 = nMotorEncoder[motorB];

e3 = nMotorEncoder[motorC];

u = k*(e3 - e2);

motor[motorB] = v + u;

motor[motorC] = v - u;

wait1Msec(2);

}

refresh();

}

*/

/*

// ПИД РЕГУЛИРОВАНИЕ

void refresh(){

motor[motorB] = 0;

motor[motorC] = 0;

wait1Msec(1000);

nMotorEncoder[motorB] = 0;

nMotorEncoder[motorC] = 0;

}

task main()

{

nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;

nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;

motor[motorB] = 50;

motor[motorC] = 50;

wait1Msec(4500);

refresh();

motor[motorB] = 50;

motor[motorC] = 0;

wait1Msec(798);

refresh();

motor[motorB] = 50;

motor[motorC] = 50;

wait1Msec(2700);

refresh();

motor[motorC] = 50;

motor[motorB] = 0;

wait1Msec(798);

refresh();

motor[motorB] = 50;

motor[motorC] = 50;

wait1Msec(1200);

refresh();

motor[motorC] = 50;

motor[motorB] = 0;

wait1Msec(798);

refresh();

motor[motorB] = 50;

motor[motorC] = 50;

wait1Msec(1500);

}

*/
